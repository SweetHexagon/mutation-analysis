<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/Main.java" />
              <option name="originalContent" value="package com.example;&#10;&#10;import java.io.*;&#10;import java.nio.charset.StandardCharsets;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.nio.file.Paths;&#10;import java.util.*;&#10;&#10;import com.example.classifier.MutationKind;&#10;import com.example.dto.CommitPairDTO;&#10;import com.example.dto.FileResultDto;&#10;import com.example.mapper.CommitPairMapper;&#10;import com.example.mapper.ResultMapper;&#10;import com.example.mutation_tester.mutation_metadata_processing.MethodCallMapper;&#10;import com.example.mutation_tester.mutations_applier.MutationApplier;&#10;import com.example.pojo.FileResult;&#10;import com.example.service.GitRepositoryManager;&#10;import com.example.util.GitUtils;&#10;import com.example.util.JsonUtils;&#10;import com.example.mutation_tester.mutations_applier.custom_patterns.LoopBreakReplacement;&#10;import com.example.mutation_tester.mutations_applier.custom_patterns.TakeWhileDropWhileReplacement;&#10;import com.fasterxml.jackson.core.type.TypeReference;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import org.apache.commons.io.FileUtils;&#10;import org.apache.maven.shared.invoker.*;&#10;import org.eclipse.jgit.lib.Repository;&#10;import org.eclipse.jgit.revwalk.RevCommit;&#10;import org.eclipse.jgit.revwalk.RevWalk;&#10;import org.springframework.beans.factory.ObjectProvider;&#10;import org.springframework.boot.CommandLineRunner;&#10;import org.springframework.boot.autoconfigure.SpringBootApplication;&#10;import org.springframework.boot.SpringApplication;&#10;&#10;import java.nio.file.FileSystemException;&#10;import java.util.concurrent.*;&#10;import java.util.regex.Matcher;&#10;import java.util.regex.Pattern;&#10;import java.util.stream.Collectors;&#10;&#10;@SpringBootApplication&#10;public class Main implements CommandLineRunner {&#10;    private final GitRepositoryManager repoManager;&#10;    private final GitUtils gitUtils;&#10;    private final MutationApplier mutationApplier;&#10;&#10;    ConcurrentMap&lt;MutationKind, Integer&gt; repoPatternCounts =&#10;            new ConcurrentHashMap&lt;&gt;();&#10;&#10;    private final ObjectProvider&lt;TreeComparator&gt; treeComparatorProvider;&#10;    private final int THREAD_COUNT = Runtime.getRuntime().availableProcessors()/2;&#10;&#10;    String localPath = &quot;repositories&quot;;&#10;    final int BATCH_SIZE = 500;&#10;    final String filteredDir = &quot;src/main/resources/programOutputFiltered&quot;;&#10;&#10;    List&lt;String&gt; repoUrls = List.of(&#10;            &quot;https://github.com/kdn251/interviews&quot;,&#10;            &quot;https://github.com/TheAlgorithms/Java&quot;,&#10;            &quot;https://github.com/NationalSecurityAgency/ghidra&quot;,&#10;            &quot;https://github.com/Stirling-Tools/Stirling-PDF&quot;,&#10;            &quot;https://github.com/google/guava&quot;,&#10;            &quot;https://github.com/ReactiveX/RxJava&quot;,&#10;            &quot;https://github.com/skylot/jadx&quot;,&#10;            &quot;https://github.com/dbeaver/dbeaver&quot;,&#10;            &quot;https://github.com/jeecgboot/JeecgBoot&quot;,&#10;            &quot;https://github.com/apache/dubbo&quot;,&#10;            &quot;https://github.com/termux/termux-app&quot;,&#10;            &quot;https://github.com/jhy/jsoup&quot;&#10;    );&#10;&#10;    List&lt;String&gt; extensions = List.of(&quot;.java&quot;);&#10;&#10;    public Main(GitRepositoryManager repoManager,&#10;                TreeComparator treeComparator,&#10;                GitUtils gitUtils,&#10;                MutationApplier mutationApplier,&#10;                ObjectProvider&lt;TreeComparator&gt; treeComparatorProvider) {&#10;        this.repoManager = repoManager;&#10;        this.gitUtils = gitUtils;&#10;        this.mutationApplier = mutationApplier;&#10;        this.treeComparatorProvider = treeComparatorProvider;&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SpringApplication.run(Main.class, args);&#10;    }&#10;&#10;    @Override&#10;    public void run(String... args) throws Exception {&#10;&#10;        // --- Configuration Paths ---&#10;        //String projectPath = &quot;D:\\Java projects\\mutation-analysis\\repositories_for_tests\\jsoup&quot;;&#10;        String projectPath = &quot;D:\\Java projects\\mutation-analysis\\repositories_for_tests\\commons-lang&quot;;&#10;&#10;        // Extract project name from path&#10;        String projectName = extractProjectName(projectPath);&#10;        System.out.println(&quot;Working with project: &quot; + projectName);&#10;&#10;        // =========================================================================&#10;        // STEP -2: Check if PITest reports already exist BEFORE any clean/build&#10;        // =========================================================================&#10;        System.out.println(&quot;STEP -2: Checking for existing PITest reports...&quot;);&#10;&#10;        // Check if PITest reports already exist&#10;        File pitReportsDir = new File(projectPath, &quot;target/pit-reports&quot;);&#10;        File lineCoverageFile = new File(pitReportsDir, &quot;linecoverage.xml&quot;);&#10;&#10;        boolean pitestReportsExist = lineCoverageFile.exists() &amp;&amp; lineCoverageFile.isFile();&#10;&#10;        if (pitestReportsExist) {&#10;            System.out.println(&quot;✅ PITest reports already exist, skipping compilation and PITest execution.&quot;);&#10;            System.out.println(&quot;✅ Found existing linecoverage.xml at: &quot; + lineCoverageFile.getAbsolutePath());&#10;        } else {&#10;            System.out.println(&quot;❌ No existing PITest reports found.&quot;);&#10;&#10;            // =========================================================================&#10;            // STEP -1: Setup PITest Plugin and Compile Project (only if reports don't exist)&#10;            // =========================================================================&#10;            System.out.println(&quot;STEP -1: Setting up PITest plugin and compiling project...&quot;);&#10;            setupPitestPlugin(projectPath);&#10;            compileMavenProject(projectPath);&#10;&#10;            // Run PITest mutation coverage analysis&#10;            runPitestMutationCoverage(projectPath);&#10;&#10;            System.out.println(&quot;✅ Project setup and compilation complete.&quot;);&#10;        }&#10;&#10;        String pitReportPath = projectPath + &quot;/target/pit-reports/linecoverage.xml&quot;;&#10;        String jsonMapPath = projectName + &quot;-method-test-mapping.json&quot;;&#10;&#10;        // =========================================================================&#10;        // STEP 0: Generate the Method-to-Test Map from the PIT Report&#10;        // =========================================================================&#10;        System.out.println(&quot;\nSTEP 0: Generating method-to-test map...&quot;);&#10;        MethodCallMapper mapper = new MethodCallMapper();&#10;        mapper.processCoverage(pitReportPath, &quot;&quot;, projectName);&#10;        System.out.println(&quot;✅ Map generation complete. Saved to: &quot; + jsonMapPath);&#10;&#10;        // =========================================================================&#10;        // STEP 1: Get List of All Mutable Methods (without applying mutations yet)&#10;        // =========================================================================&#10;        System.out.println(&quot;\nSTEP 1: Identifying mutable methods...&quot;);&#10;        var potentialMutationResults = mutationApplier.identifyMutableMethods(&#10;                MutationApplier.CustomMutations.SAFE_STREAM_METHOD_REPLACEMENT, projectPath);&#10;        Set&lt;String&gt; mutableMethods = new HashSet&lt;&gt;(potentialMutationResults);&#10;        System.out.println(&quot;✅ Found &quot; + mutableMethods.size() + &quot; mutable methods across all files.&quot;);&#10;&#10;        // =========================================================================&#10;        // STEP 2: Load the Full Test Map from the Generated JSON&#10;        // =========================================================================&#10;        System.out.println(&quot;\nSTEP 2: Loading test map from JSON...&quot;);&#10;        Map&lt;String, Set&lt;String&gt;&gt; allTestsMap = loadTestMapFromJson(jsonMapPath);&#10;&#10;        // =========================================================================&#10;        // STEP 3: Filter for Tests Covering Mutable Methods&#10;        // =========================================================================&#10;        System.out.println(&quot;\nSTEP 3: Filtering tests for mutable methods...&quot;);&#10;        Map&lt;String, Set&lt;String&gt;&gt; testsToRunMap = allTestsMap.entrySet().stream()&#10;                .filter(entry -&gt; mutableMethods.contains(entry.getKey()))&#10;                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));&#10;&#10;        System.out.println(&quot;✅ Found &quot; + testsToRunMap.values().stream().mapToLong(Set::size).sum()&#10;                + &quot; relevant tests to run.&quot;);&#10;        long uniqueCount = testsToRunMap.values().stream()&#10;                .flatMap(Set::stream)&#10;                .distinct()&#10;                .count();&#10;        System.out.println(&quot;✅ Found &quot; + uniqueCount + &quot; unique relevant tests to run.&quot;);&#10;&#10;        // =========================================================================&#10;        // STEP 4: Mutate and Test Each Method Individually&#10;        // =========================================================================&#10;        System.out.println(&quot;\nSTEP 4: Testing mutations one method at a time...&quot;);&#10;&#10;        Map&lt;String, Set&lt;String&gt;&gt; globalFailedTestsReport = new HashMap&lt;&gt;();&#10;        int methodCount = 0;&#10;        int totalMethods = testsToRunMap.size();&#10;&#10;        for (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : testsToRunMap.entrySet()) {&#10;            String methodSignature = entry.getKey();&#10;            Set&lt;String&gt; relevantTests = entry.getValue();&#10;            methodCount++;&#10;&#10;            System.out.printf(&quot;\n[%d/%d] Processing method: %s%n&quot;, methodCount, totalMethods, methodSignature);&#10;            System.out.println(&quot;  Relevant tests: &quot; + relevantTests.size());&#10;&#10;            try {&#10;                // Reset project to clean state&#10;                System.out.println(&quot;   Resetting project to clean state...&quot;);&#10;                resetProjectToCleanState(projectPath);&#10;&#10;                // Apply mutation to this specific method only&#10;                System.out.println(&quot;   Applying mutation to method...&quot;);&#10;                boolean mutationApplied = mutationApplier.applyMutationToSpecificMethod(&#10;                        MutationApplier.CustomMutations.SAFE_STREAM_METHOD_REPLACEMENT,&#10;                        projectPath,&#10;                        methodSignature);&#10;&#10;                if (!mutationApplied) {&#10;                    System.out.println(&quot;  ⚠️ No mutation could be applied to this method, skipping...&quot;);&#10;                    continue;&#10;                }&#10;&#10;                // Run tests for this method&#10;                System.out.println(&quot;   Running tests for mutated method...&quot;);&#10;                Map&lt;String, Set&lt;String&gt;&gt; methodTestsMap = new HashMap&lt;&gt;();&#10;                methodTestsMap.put(methodSignature, relevantTests);&#10;&#10;                Map&lt;String, Set&lt;String&gt;&gt; failedTestsForMethod = runBatchedMavenTests(methodTestsMap, projectPath);&#10;&#10;                // Collect results&#10;                if (!failedTestsForMethod.isEmpty()) {&#10;                    globalFailedTestsReport.putAll(failedTestsForMethod);&#10;                    System.out.println(&quot;  ✅ Mutation detected! &quot; + failedTestsForMethod.get(methodSignature).size() + &quot; tests failed.&quot;);&#10;                } else {&#10;                    System.out.println(&quot;  ❌ Mutation not detected - all tests passed.&quot;);&#10;                }&#10;&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;  ❌ Error processing method &quot; + methodSignature + &quot;: &quot; + e.getMessage());&#10;                e.printStackTrace();&#10;            }&#10;        }&#10;&#10;        // Final reset to clean state&#10;        System.out.println(&quot;\n Final reset to clean state...&quot;);&#10;        resetProjectToCleanState(projectPath);&#10;&#10;        // =========================================================================&#10;        // STEP 5: Print Final Report&#10;        // =========================================================================&#10;        System.out.println(&quot;\n--- FINAL REPORT ---&quot;);&#10;        if (globalFailedTestsReport.isEmpty()) {&#10;            System.out.println(&quot;✅ No mutations were detected by the test suite.&quot;);&#10;        } else {&#10;            System.out.println(&quot;❌ Mutations Detected! Found &quot; + globalFailedTestsReport.size() + &quot; methods with failing tests.&quot;);&#10;        }&#10;&#10;        // =====================&#10;        // STATISTICS PER METHOD&#10;        // =====================&#10;        System.out.println(&quot;\n--- STATISTICS PER MUTATED METHOD ---&quot;);&#10;        testsToRunMap.forEach((method, relevantTests) -&gt; {&#10;            int totalRelevant = relevantTests.size();&#10;            Set&lt;String&gt; failedTests = globalFailedTestsReport.getOrDefault(method, Collections.emptySet());&#10;            int failed = failedTests.size();&#10;&#10;            // For passed calculation, we need to be more careful&#10;            // If we have failed tests, then passed = relevant - failed&#10;            // But we need to make sure we don't go negative&#10;            int passed = Math.max(0, totalRelevant - failed);&#10;&#10;            System.out.println(&quot;Method: &quot; + method);&#10;            System.out.println(&quot;  Total relevant tests: &quot; + totalRelevant);&#10;            System.out.println(&quot;  Passed: &quot; + passed);&#10;            System.out.println(&quot;  Failed: &quot; + failed);&#10;        });&#10;    }&#10;&#10;    private static Map&lt;String, Set&lt;String&gt;&gt; loadTestMapFromJson(String jsonFilePath) {&#10;        ObjectMapper objectMapper = new ObjectMapper();&#10;        Map&lt;String, Set&lt;String&gt;&gt; testMap = new HashMap&lt;&gt;();&#10;&#10;        try {&#10;            Map&lt;String, List&lt;String&gt;&gt; rawMap = objectMapper.readValue(&#10;                    new File(jsonFilePath),&#10;                    new TypeReference&lt;Map&lt;String, List&lt;String&gt;&gt;&gt;() {}&#10;            );&#10;&#10;            for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : rawMap.entrySet()) {&#10;                testMap.put(entry.getKey(), new HashSet&lt;&gt;(entry.getValue()));&#10;            }&#10;&#10;            System.out.println(&quot;Successfully loaded test map from: &quot; + jsonFilePath);&#10;&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error loading test map from JSON file: &quot; + jsonFilePath);&#10;            System.err.println(&quot;Error details: &quot; + e.getMessage());&#10;        }&#10;        return testMap;&#10;    }&#10;&#10;    private static final Pattern TEST_SUMMARY_PATTERN = Pattern.compile(&quot;Tests run: (\\d+), Failures: (\\d+), Errors: (\\d+), Skipped: (\\d+)&quot;);&#10;    private static final Pattern FAILURE_LINE_PATTERN = Pattern.compile(&quot;\\[ERROR\\]\\s+([^\\s]+)\\s+--\\s+Time elapsed:.*&lt;&lt;&lt; FAILURE!&quot;);&#10;    private static final Pattern ERROR_LINE_PATTERN = Pattern.compile(&quot;\\[ERROR\\]\\s+([^\\s]+)\\s+--\\s+Time elapsed:.*&lt;&lt;&lt; ERROR!&quot;);&#10;&#10;    public Map&lt;String, Set&lt;String&gt;&gt; runBatchedMavenTests(&#10;            Map&lt;String, Set&lt;String&gt;&gt; testsToRunMap,&#10;            String projectPath&#10;    ) throws IOException, MavenInvocationException {&#10;        Map&lt;String, Set&lt;String&gt;&gt; failedTestsReport = new HashMap&lt;&gt;();&#10;        int totalRun = 0, totalFailures = 0, totalErrors = 0, totalSkipped = 0;&#10;&#10;        Invoker invoker = new DefaultInvoker();&#10;        invoker.setWorkingDirectory(new File(projectPath));&#10;        File mavenHome = new File(System.getenv(&quot;MAVEN_HOME&quot;));&#10;        if (!mavenHome.isDirectory()) {&#10;            throw new IllegalStateException(&quot;MAVEN_HOME must point to a valid directory&quot;);&#10;        }&#10;        invoker.setMavenHome(mavenHome);&#10;&#10;        for (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : testsToRunMap.entrySet()) {&#10;            String batchKey = entry.getKey();&#10;            Set&lt;String&gt; tests = entry.getValue();&#10;            if (tests.isEmpty()) continue;&#10;&#10;            try {&#10;                // Convert test format for Maven Surefire&#10;                Set&lt;String&gt; testClasses = new HashSet&lt;&gt;();&#10;                for (String test : tests) {&#10;                    if (test.contains(&quot;#&quot;)) {&#10;                        // Extract class name from &quot;package.Class#method&quot;&#10;                        String className = test.substring(0, test.indexOf(&quot;#&quot;));&#10;                        testClasses.add(className);&#10;                    } else {&#10;                        // If it's just a class name&#10;                        testClasses.add(test);&#10;                    }&#10;                }&#10;&#10;                // Join test classes with comma for -Dtest parameter&#10;                String testParameter = String.join(&quot;,&quot;, testClasses);&#10;&#10;                // Debug: print what tests we're running&#10;                System.out.println(&quot;DEBUG: Running tests for method &quot; + batchKey + &quot;:&quot;);&#10;                System.out.println(&quot;  Original tests: &quot; + tests.size());&#10;                System.out.println(&quot;  Test classes: &quot; + testClasses.size());&#10;                System.out.println(&quot;  Test parameter: &quot; + testParameter);&#10;&#10;                InvocationRequest req = new DefaultInvocationRequest();&#10;                req.setPomFile(new File(projectPath, &quot;pom.xml&quot;));&#10;                req.setGoals(Collections.singletonList(&quot;test&quot;));&#10;                req.setInputStream(InputStream.nullInputStream());&#10;&#10;                Properties props = new Properties();&#10;                // Use -Dtest parameter instead of includesFile&#10;                props.setProperty(&quot;test&quot;, testParameter);&#10;                props.setProperty(&quot;maven.test.failure.ignore&quot;, &quot;true&quot;);&#10;                props.setProperty(&quot;failIfNoTests&quot;, &quot;false&quot;);&#10;                req.setProperties(props);&#10;&#10;                ByteArrayOutputStream baos = new ByteArrayOutputStream();&#10;                PrintStreamHandler handler = new PrintStreamHandler(new PrintStream(baos), false);&#10;                invoker.setOutputHandler(handler);&#10;                invoker.setErrorHandler(handler);&#10;&#10;                InvocationResult result = invoker.execute(req);&#10;                String mvnLog = baos.toString();&#10;&#10;                // Debug: print Maven log excerpt for verification&#10;                System.out.println(&quot;DEBUG: Maven execution result (exit code: &quot; + result.getExitCode() + &quot;)&quot;);&#10;                String[] logLines = mvnLog.split(&quot;\n&quot;);&#10;                for (String logLine : logLines) {&#10;                    if (logLine.contains(&quot;Tests run:&quot;) || logLine.contains(&quot;Running&quot;) ||&#10;                        logLine.contains(&quot;No tests to run&quot;) || logLine.contains(&quot;T E S T S&quot;)) {&#10;                        System.out.println(&quot;  &quot; + logLine.trim());&#10;                    }&#10;                }&#10;&#10;                Matcher summaryMatcher = TEST_SUMMARY_PATTERN.matcher(mvnLog);&#10;                int run = 0, failures = 0, errors = 0, skipped = 0;&#10;                while (summaryMatcher.find()) {&#10;                    run = Integer.parseInt(summaryMatcher.group(1));&#10;                    failures = Integer.parseInt(summaryMatcher.group(2));&#10;                    errors = Integer.parseInt(summaryMatcher.group(3));&#10;                    skipped = Integer.parseInt(summaryMatcher.group(4));&#10;                }&#10;&#10;                // If no tests were found, this might indicate a mapping issue&#10;                if (run == 0) {&#10;                    System.out.println(&quot;WARNING: No tests were executed for method &quot; + batchKey);&#10;                    System.out.println(&quot;This could indicate a mapping issue between method and test names.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                int passed = run - failures - errors - skipped;&#10;                totalRun += run;&#10;                totalFailures += failures;&#10;                totalErrors += errors;&#10;                totalSkipped += skipped;&#10;&#10;                System.out.printf(&#10;                        &quot;[BATCH %s] run=%d, passed=%d, failures=%d, errors=%d, skipped=%d%n&quot;,&#10;                        batchKey, run, passed, failures, errors, skipped&#10;                );&#10;&#10;                // Collect failed tests&#10;                Set&lt;String&gt; failedThisBatch = new HashSet&lt;&gt;();&#10;&#10;                Matcher fm = FAILURE_LINE_PATTERN.matcher(mvnLog);&#10;                while (fm.find()) {&#10;                    String formatted = convertSurefireToCustomFormat(fm.group(1));&#10;                    failedThisBatch.add(formatted);&#10;                }&#10;&#10;                Matcher em = ERROR_LINE_PATTERN.matcher(mvnLog);&#10;                while (em.find()) {&#10;                    String formatted = convertSurefireToCustomFormat(em.group(1));&#10;                    failedThisBatch.add(formatted);&#10;                }&#10;&#10;                // If we detected failures but didn't capture any failed tests, use fallback&#10;                if ((failures &gt; 0 || errors &gt; 0) &amp;&amp; failedThisBatch.isEmpty()) {&#10;                    System.out.println(&quot;Warning: Detected &quot; + failures + &quot; failures and &quot; + errors + &quot; errors but couldn't parse test names. Using fallback strategy.&quot;);&#10;                    // Add all tests from this batch as potentially failed&#10;                    failedThisBatch.addAll(tests);&#10;                }&#10;&#10;                if (!failedThisBatch.isEmpty()) {&#10;                    failedTestsReport.put(batchKey, failedThisBatch);&#10;                    System.out.println(&quot;Captured &quot; + failedThisBatch.size() + &quot; failed tests for method: &quot; + batchKey);&#10;                }&#10;&#10;            } finally {&#10;                invoker.setOutputHandler(new PrintStreamHandler(System.out, true));&#10;                invoker.setErrorHandler(new PrintStreamHandler(System.err, true));&#10;            }&#10;        }&#10;&#10;        int totalPassed = totalRun - totalFailures - totalErrors - totalSkipped;&#10;        System.out.printf(&#10;                &quot;TOTAL → run=%d, passed=%d, failures=%d, errors=%d, skipped=%d%n&quot;,&#10;                totalRun, totalPassed, totalFailures, totalErrors, totalSkipped&#10;        );&#10;&#10;        return failedTestsReport;&#10;    }&#10;&#10;    private static String convertSurefireToCustomFormat(String surefireFormat) {&#10;        if (surefireFormat == null || surefireFormat.isEmpty()) {&#10;            return surefireFormat;&#10;        }&#10;        int lastDot = surefireFormat.lastIndexOf(&quot;.&quot;);&#10;        if (lastDot != -1) {&#10;            String className = surefireFormat.substring(0, lastDot);&#10;            String methodName = surefireFormat.substring(lastDot + 1);&#10;            return className + &quot;#&quot; + methodName;&#10;        }&#10;        return surefireFormat;&#10;    }&#10;&#10;    // Helper method to extract failed test names from Maven output.&#10;// This is a rudimentary parser; for production, consider parsing Surefire's XML reports.&#10;    private static String extractFailedTestName(String line, Set&lt;String&gt; allTestsInBatch) {&#10;        // Example lines:&#10;        // [ERROR] org.jsoup.nodes.AttributesTest.testListSkipsInternal -- Time elapsed: 0.035 s &lt;&lt;&lt; FAILURE!&#10;        // [ERROR] Failures: AttributesTest.testListSkipsInternal&#10;        // [ERROR] Error: TestClass.testMethod&#10;        if (line.contains(&quot;&lt;&lt;&lt; FAILURE!&quot;)) {&#10;            // Try to find the full test name (class#method)&#10;            int classMethodEnd = line.indexOf(&quot; -- Time elapsed:&quot;);&#10;            if (classMethodEnd != -1) {&#10;                String candidate = line.substring(line.indexOf(&quot;]&quot;) + 2, classMethodEnd).trim();&#10;                // Need to convert to your format (e.g., org.jsoup.nodes.AttributesTest#testListSkipsInternal)&#10;                if (candidate.contains(&quot;.&quot;)) {&#10;                    int lastDot = candidate.lastIndexOf(&quot;.&quot;);&#10;                    if (lastDot != -1) {&#10;                        String className = candidate.substring(0, lastDot);&#10;                        String methodName = candidate.substring(lastDot + 1);&#10;                        String formatted = className + &quot;#&quot; + methodName;&#10;                        if (allTestsInBatch.contains(formatted)) {&#10;                            return formatted;&#10;                        }&#10;                        // Also check for just class name if the test filter was a class&#10;                        if (allTestsInBatch.contains(className)) {&#10;                            return className;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } else if (line.contains(&quot;[ERROR] Failures: &quot;) || line.contains(&quot;[ERROR] Error: &quot;)) {&#10;            String testPart = line.substring(line.indexOf(&quot;:&quot;) + 1).trim();&#10;            // It might be &quot;TestClass.testMethod&quot; or &quot;TestClass.testMethod: lineNumber&quot;&#10;            int colonIndex = testPart.indexOf(&quot;:&quot;);&#10;            if (colonIndex != -1) {&#10;                testPart = testPart.substring(0, colonIndex);&#10;            }&#10;            testPart = testPart.trim();&#10;&#10;            // Convert Surefire's &quot;package.Class.method&quot; to your &quot;package.Class#method&quot;&#10;            int lastDot = testPart.lastIndexOf(&quot;.&quot;);&#10;            if (lastDot != -1) {&#10;                String className = testPart.substring(0, lastDot);&#10;                String methodName = testPart.substring(lastDot + 1);&#10;                String formatted = className + &quot;#&quot; + methodName;&#10;                if (allTestsInBatch.contains(formatted)) {&#10;                    return formatted;&#10;                }&#10;                // Also check for just class name if the test filter was a class&#10;                if (allTestsInBatch.contains(className)) {&#10;                    return className;&#10;                }&#10;            } else {&#10;                // If it's just a class name (e.g., &quot;MyTestClass&quot;)&#10;                if (allTestsInBatch.contains(testPart)) {&#10;                    return testPart;&#10;                }&#10;            }&#10;        }&#10;        return null; // Test name not found or line didn't match expected failure pattern&#10;    }&#10;&#10;    public void presentation(List&lt;String&gt; repoUrls) throws InterruptedException {&#10;        for (String repoUrl : repoUrls) {&#10;&#10;            for (MutationKind k : MutationKind.values()) {&#10;                repoPatternCounts.put(k, 0);&#10;            }&#10;&#10;            String repoName = repoUrl.substring(repoUrl.lastIndexOf(&quot;/&quot;) + 1);&#10;            String repoDir  = localPath + File.separator + repoName;&#10;&#10;            System.out.println(&quot;Processing repo: &quot; + repoName);&#10;&#10;            List&lt;CommitPairWithFiles&gt; commitPairs;&#10;&#10;            try {&#10;                var repository = GitUtils.ensureClonedAndLoaded(repoUrl, repoDir);&#10;&#10;                String cacheFilePath = &quot;src/main/resources/cache/&quot; + repoName + &quot;-commitPairs.json&quot;;&#10;                File cacheFile = new File(cacheFilePath);&#10;&#10;                if (cacheFile.exists()) {&#10;                    System.out.println(&quot;Loading cached commit pairs...&quot;);&#10;                    List&lt;CommitPairDTO&gt; dtos = JsonUtils.readCommitPairDTOsFromFile(cacheFilePath);&#10;                    commitPairs = CommitPairMapper.fromDTOs(repository, dtos);&#10;                } else {&#10;                    System.out.println(&quot;Generating commit pairs...&quot;);&#10;                    commitPairs = GitUtils.processRepo(repoUrl, repoDir, extensions, false);&#10;                    List&lt;CommitPairDTO&gt; dtos = CommitPairMapper.toDTOs(commitPairs);&#10;                    JsonUtils.writeCommitPairDTOsToFile(dtos, cacheFilePath);&#10;                }&#10;&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error processing &quot; + repoUrl + &quot;: &quot; + e.getMessage());&#10;                continue;&#10;            }&#10;&#10;            if (commitPairs == null || commitPairs.isEmpty()) {&#10;                System.out.println(&quot;No commits for &quot; + repoUrl);&#10;                continue;&#10;            }&#10;&#10;            JsonUtils.initializeJsonOutput(repoUrl);&#10;&#10;            int totalPairs = commitPairs.size();&#10;            System.out.println(&quot;Total commit pairs to process: &quot; + totalPairs);&#10;&#10;            for (int batchStart = 0; batchStart &lt; totalPairs; batchStart += BATCH_SIZE) {&#10;                int batchEnd = Math.min(batchStart + BATCH_SIZE, totalPairs);&#10;                List&lt;CommitPairWithFiles&gt; batch = commitPairs.subList(batchStart, batchEnd);&#10;&#10;                System.out.printf(&quot;Processing batch %d - %d / %d%n&quot;, batchStart + 1, batchEnd, totalPairs);&#10;                processBatch(batch, repoDir, repoUrl);&#10;&#10;                long used = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();&#10;                System.out.println(&quot;Memory used (MB): &quot; + used / (1024 * 1024));&#10;            }&#10;&#10;            JsonUtils.appendPatternCounts(repoUrl, repoPatternCounts);&#10;            System.out.println(&quot;Wrote patternCounts for &quot; + repoName);&#10;&#10;            JsonUtils.filterUniqueOperations(repoUrl);&#10;&#10;            repoManager.closeRepository();&#10;&#10;            System.out.println();&#10;        }&#10;    }&#10;&#10;    private void processBatch(List&lt;CommitPairWithFiles&gt; batch, String repoDir, String repoUrl)&#10;    {&#10;        long totalStart = System.currentTimeMillis();&#10;&#10;        int totalFiles = batch.stream()&#10;                .mapToInt(pair -&gt; pair.changedFiles().size())&#10;                .sum();&#10;        System.out.printf(&quot;Processing %d commit pairs with a total of %d changed files%n&quot;, batch.size(), totalFiles);&#10;&#10;        ExecutorService exec = Executors.newFixedThreadPool(THREAD_COUNT);&#10;        CompletionService&lt;Void&gt; cs = new ExecutorCompletionService&lt;&gt;(exec);&#10;&#10;        Queue&lt;FileResultDto&gt; batchResults = new ConcurrentLinkedQueue&lt;&gt;();&#10;        ConcurrentMap&lt;MutationKind, Integer&gt; safePatternCounts = new ConcurrentHashMap&lt;&gt;();&#10;&#10;        // Silence Spoon JDT errors&#10;        System.setErr(new ErrorFilterPrintStream(System.err));&#10;&#10;        ThreadLocal&lt;TreeComparator&gt; localComparator = ThreadLocal.withInitial(() -&gt; treeComparatorProvider.getObject());&#10;&#10;        long submissionStart = System.currentTimeMillis();&#10;        int taskCount = 0;&#10;&#10;        for (CommitPairWithFiles pair : batch) {&#10;            for (String file : pair.changedFiles()) {&#10;                cs.submit(() -&gt; {&#10;                    if (Thread.currentThread().isInterrupted()) return null;&#10;&#10;                    FileResult result = localComparator.get().compareFileInTwoCommits(&#10;                            repoDir, pair.oldCommit(), pair.newCommit(), file, false&#10;                    );&#10;&#10;                    if (result != null) {&#10;&#10;                        Map&lt;String, Integer&gt; fileMetrics = result.getMetrics();&#10;                        if (fileMetrics != null) {&#10;                            fileMetrics.forEach((key, count) -&gt; {&#10;                                try {&#10;                                    MutationKind kind = MutationKind.valueOf(key);&#10;                                    safePatternCounts.merge(kind, count, Integer::sum);&#10;                                } catch (IllegalArgumentException ignored) {&#10;                                    // Ignore non-pattern metrics&#10;                                }&#10;                            });&#10;                        }&#10;&#10;                        if (!result.getEditOperations().isEmpty()) {&#10;                            FileResultDto dto = ResultMapper.toDto(result);&#10;                            batchResults.add(dto);&#10;                        }&#10;&#10;                    }&#10;&#10;&#10;&#10;                    return null;&#10;                });&#10;                taskCount++;&#10;            }&#10;        }&#10;&#10;        long submissionEnd = System.currentTimeMillis();&#10;        System.out.printf(&quot;Time to submit %d tasks: %.2f seconds%n&quot;, taskCount, (submissionEnd - submissionStart) / 1000.0);&#10;&#10;        int completed = 0;&#10;        long processingStart = System.currentTimeMillis();&#10;        long lastPrintTime = System.currentTimeMillis();&#10;&#10;        while (completed &lt; taskCount) {&#10;            try {&#10;                Future&lt;Void&gt; future = cs.take();&#10;                future.get();&#10;                completed++;&#10;&#10;                long now = System.currentTimeMillis();&#10;                if (now - lastPrintTime &gt;= 1000 || completed == taskCount) { // throttle to once per second or on final&#10;                    printProgressBar(completed, taskCount);&#10;                    lastPrintTime = now;&#10;                }&#10;&#10;            } catch (ExecutionException e) {&#10;                System.err.println(&quot;Task failed: &quot; + e.getCause());&#10;            } catch (InterruptedException e) {&#10;                System.err.println(&quot;Processing interrupted.&quot;);&#10;                Thread.currentThread().interrupt(); // Preserve interrupt flag&#10;                break;&#10;            }&#10;        }&#10;&#10;        long processingEnd = System.currentTimeMillis();&#10;        System.out.printf(&quot;Time to process batch: %.2f seconds%n&quot;, (processingEnd - processingStart) / 1000.0);&#10;&#10;        exec.shutdown();&#10;        System.out.println();&#10;&#10;        long jsonStart = System.currentTimeMillis();&#10;        JsonUtils.appendBatchResults(repoUrl, new ArrayList&lt;&gt;(batchResults));&#10;        batchResults.clear();&#10;        long jsonEnd = System.currentTimeMillis();&#10;        System.out.printf(&quot;Time to write JSON results: %.2f seconds%n&quot;, (jsonEnd - jsonStart) / 1000.0);&#10;&#10;        long totalEnd = System.currentTimeMillis();&#10;        System.out.printf(&quot;Total time for processBatch: %.2f seconds%n&quot;, (totalEnd - totalStart) / 1000.0);&#10;&#10;        // Update shared repoPatternCounts after batch is done&#10;        safePatternCounts.forEach((k, v) -&gt;&#10;                repoPatternCounts.merge(k, v, Integer::sum)&#10;        );&#10;    }&#10;&#10;    private  void printProgressBar(int current, int total) {&#10;        int width = 50;&#10;        int filled = (int)(width * current / (double)total);&#10;        StringBuilder b = new StringBuilder(&quot;\r[&quot;);&#10;        for (int i = 0; i &lt; width; i++) {&#10;            b.append(i &lt; filled ? '=' : ' ');&#10;        }&#10;        b.append(&quot;] &quot;)&#10;                .append(String.format(&quot;%3d%%&quot;, (int)(current*100.0/total)));&#10;        System.out.print(b);&#10;        System.out.flush();&#10;    }&#10;&#10;    public void loopBreakReplacementTest(){&#10;        try {&#10;            Path inputPath = Paths.get(&quot;src/main/java/com/example/mutations_applier/test/before.java&quot;);&#10;            // Path to the output file &quot;after.java&quot;&#10;            Path outputPath = Paths.get(&quot;src/main/java/com/example/mutations_applier/test/after.java&quot;);&#10;&#10;            // Read the content of &quot;before.java&quot;&#10;            String originalCode = new String(Files.readAllBytes(inputPath));&#10;&#10;            // Apply the mutation using loopBreakReplacement&#10;            LoopBreakReplacement mutator = new LoopBreakReplacement();&#10;            String mutatedCode = mutator.mutate(originalCode).getMutatedUnit().toString();&#10;&#10;            // Write the mutated code to &quot;after.java&quot;&#10;            Files.write(outputPath, mutatedCode.getBytes());&#10;&#10;            System.out.println(&quot;Mutation applied. Check after.java.&quot;);&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public  void manualTest() {&#10;&#10;&#10;        String localRepoName = &quot;D:\\Java projects\\mutation-analysis\\repositories\\spring-framework\\.git&quot;;&#10;        String oldSha = &quot;253f321e8b81aa5f652117514c37cb541f2e5ecf&quot;;&#10;        String newSha = &quot;014a395aed7b3f40bb05f1591149e833f2bf7537&quot;;&#10;        String fileName = &quot;spring-context/src/test/java/org/springframework/aop/framework/AbstractAopProxyTests.java&quot;;&#10;&#10;        String outputDir = &quot;D:\\Java projects\\mutation-analysis\\src\\main\\resources\\extractedFiles&quot;;&#10;        cleanUp(outputDir);&#10;&#10;&#10;        Repository repo = GitUtils.ensureClonedAndLoaded(&quot;&quot;, localRepoName);&#10;        RevCommit oldCommit = null;&#10;        RevCommit newCommit = null;&#10;        try (RevWalk walk = new RevWalk(repo)) {&#10;            oldCommit = walk.parseCommit(repo.resolve(oldSha));&#10;            newCommit = walk.parseCommit(repo.resolve(newSha));&#10;        } catch (Exception exception){&#10;            exception.printStackTrace();&#10;        }&#10;&#10;&#10;        //List&lt;String&gt; extractedPaths = GitUtils.extractFileAtTwoCommits(localPath + &quot;\\&quot; + localRepoName, relativePath, oldSha, newSha, outputDir);&#10;        //List&lt;String&gt; extractedPaths = List.of(&quot;D:\\\\Java projects\\\\mutation-analysis\\\\src\\\\main\\\\java\\\\com\\\\example\\\\test\\\\file1.java&quot;, &quot;D:\\\\Java projects\\\\mutation-analysis\\\\src\\\\main\\\\java\\\\com\\\\example\\\\test\\\\file2.java&quot;);&#10;&#10;        TreeComparator localComparator = treeComparatorProvider.getObject();&#10;        FileResult result = localComparator.compareFileInTwoCommits(&quot;&quot;, oldCommit, newCommit, fileName, true);&#10;&#10;        if (result != null) {&#10;            System.out.println(result);&#10;        } else {&#10;            System.out.println(&quot;Comparison failed.&quot;);&#10;        }&#10;&#10;    }&#10;&#10;    public  void manualTestLocal() {&#10;&#10;        TreeComparator localComparator = treeComparatorProvider.getObject();&#10;        FileResult result = localComparator.compareTwoFilePaths(&#10;                &quot;D:\\Java projects\\mutation-analysis\\src\\main\\java\\com\\example\\test\\file1.java&quot;,&#10;                &quot;D:\\Java projects\\mutation-analysis\\src\\main\\java\\com\\example\\test\\file2.java&quot;,&#10;                true&#10;        );&#10;&#10;        if (result != null) {&#10;            System.out.println(result);&#10;        } else {&#10;            System.out.println(&quot;Comparison failed.&quot;);&#10;        }&#10;&#10;    }&#10;&#10;    public  void cleanUp(String path) {&#10;        try {&#10;            File dir = new File(path);&#10;            if (dir.exists() &amp;&amp; dir.isDirectory()) {&#10;                FileUtils.deleteDirectory(dir);&#10;            }&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Cleanup failed on: &quot; + ((e instanceof FileSystemException)&#10;                    ? ((FileSystemException)e).getFile() + &quot;  because: &quot; + ((FileSystemException)e).getReason()&#10;                    : e.getMessage()));&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extracts the project name from the given project path.&#10;     * @param projectPath the full path to the project&#10;     * @return the project name (last directory in the path)&#10;     */&#10;    private String extractProjectName(String projectPath) {&#10;        if (projectPath == null || projectPath.isEmpty()) {&#10;            return &quot;unknown-project&quot;;&#10;        }&#10;&#10;        // Handle both forward and backward slashes&#10;        String normalizedPath = projectPath.replace('/', File.separatorChar);&#10;&#10;        // Remove trailing separator if present&#10;        if (normalizedPath.endsWith(File.separator)) {&#10;            normalizedPath = normalizedPath.substring(0, normalizedPath.length() - 1);&#10;        }&#10;&#10;        int lastSeparatorIndex = normalizedPath.lastIndexOf(File.separatorChar);&#10;        if (lastSeparatorIndex == -1) {&#10;            return normalizedPath; // No separator found, return the whole path&#10;        }&#10;&#10;        return normalizedPath.substring(lastSeparatorIndex + 1);&#10;    }&#10;&#10;    /**&#10;     * Resets the project to clean state using git checkout .&#10;     * @param projectPath the path to the project directory&#10;     * @throws Exception if git reset fails&#10;     */&#10;    private void resetProjectToCleanState(String projectPath) throws Exception {&#10;        try {&#10;            ProcessBuilder pb = new ProcessBuilder(&quot;git&quot;, &quot;checkout&quot;, &quot;.&quot;);&#10;            pb.directory(new File(projectPath));&#10;            pb.redirectErrorStream(true);&#10;&#10;            Process process = pb.start();&#10;&#10;            // Read output for debugging&#10;            StringBuilder output = new StringBuilder();&#10;            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {&#10;                String line;&#10;                while ((line = reader.readLine()) != null) {&#10;                    output.append(line).append(&quot;\n&quot;);&#10;                }&#10;            }&#10;&#10;            int exitCode = process.waitFor();&#10;&#10;            if (exitCode != 0) {&#10;                System.err.println(&quot;Git checkout failed with exit code: &quot; + exitCode);&#10;                System.err.println(&quot;Output: &quot; + output.toString());&#10;                throw new RuntimeException(&quot;Failed to reset project to clean state&quot;);&#10;            }&#10;&#10;            // Optional: also clean any untracked files&#10;            ProcessBuilder pbClean = new ProcessBuilder(&quot;git&quot;, &quot;clean&quot;, &quot;-fd&quot;);&#10;            pbClean.directory(new File(projectPath));&#10;            pbClean.redirectErrorStream(true);&#10;&#10;            Process cleanProcess = pbClean.start();&#10;            cleanProcess.waitFor(); // We don't check exit code for clean as it's optional&#10;&#10;        } catch (IOException | InterruptedException e) {&#10;            throw new Exception(&quot;Failed to reset project state: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    // =========================================================================&#10;    // STEP -1: Setup PITest Plugin and Compile Project&#10;    // =========================================================================&#10;    private void setupPitestPlugin(String projectPath) throws Exception {&#10;        System.out.println(&quot;Checking PITest plugin configuration...&quot;);&#10;&#10;        // Check if the PITest plugin is already configured in the pom.xml&#10;        File pomFile = new File(projectPath, &quot;pom.xml&quot;);&#10;        if (!pomFile.exists()) {&#10;            throw new FileNotFoundException(&quot;pom.xml not found in the project directory: &quot; + projectPath);&#10;        }&#10;&#10;        // Check for the presence of the PITest plugin in the pom.xml&#10;        // Look for both groupId and artifactId separately since they're on different lines&#10;        boolean hasOrgPitest = false;&#10;        boolean hasPitestMaven = false;&#10;&#10;        try (var lines = Files.lines(pomFile.toPath())) {&#10;            for (String line : lines.collect(Collectors.toList())) {&#10;                if (line.contains(&quot;org.pitest&quot;)) {&#10;                    hasOrgPitest = true;&#10;                }&#10;                if (line.contains(&quot;pitest-maven&quot;)) {&#10;                    hasPitestMaven = true;&#10;                }&#10;                // If we found both, no need to continue&#10;                if (hasOrgPitest &amp;&amp; hasPitestMaven) {&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;&#10;        boolean pitestConfigured = hasOrgPitest &amp;&amp; hasPitestMaven;&#10;&#10;        if (pitestConfigured) {&#10;            System.out.println(&quot;✅ PITest plugin is already configured.&quot;);&#10;            return;&#10;        }&#10;&#10;        System.out.println(&quot;⚠️ PITest plugin not found. Adding configuration to pom.xml...&quot;);&#10;&#10;        // For this demo, we'll assume the plugin should already be configured manually&#10;        // In a real scenario, you would programmatically add it to the pom.xml&#10;        System.out.println(&quot;Please ensure PITest plugin is configured in your pom.xml&quot;);&#10;    }&#10;&#10;    // =========================================================================&#10;    // STEP -2: Compile Maven Project&#10;    // =========================================================================&#10;    private void compileMavenProject(String projectPath) throws Exception {&#10;        System.out.println(&quot;Compiling Maven project...&quot;);&#10;&#10;        Invoker invoker = new DefaultInvoker();&#10;        invoker.setWorkingDirectory(new File(projectPath));&#10;        File mavenHome = new File(System.getenv(&quot;MAVEN_HOME&quot;));&#10;        if (!mavenHome.isDirectory()) {&#10;            throw new IllegalStateException(&quot;MAVEN_HOME must point to a valid directory&quot;);&#10;        }&#10;        invoker.setMavenHome(mavenHome);&#10;&#10;        InvocationRequest req = new DefaultInvocationRequest();&#10;        req.setPomFile(new File(projectPath, &quot;pom.xml&quot;));&#10;        req.setGoals(Arrays.asList(&quot;clean&quot;, &quot;compile&quot;, &quot;test-compile&quot;));&#10;        req.setInputStream(InputStream.nullInputStream());&#10;&#10;        ByteArrayOutputStream baos = new ByteArrayOutputStream();&#10;        PrintStreamHandler handler = new PrintStreamHandler(new PrintStream(baos), false);&#10;        invoker.setOutputHandler(handler);&#10;        invoker.setErrorHandler(handler);&#10;&#10;        InvocationResult result = invoker.execute(req);&#10;        String mvnLog = baos.toString();&#10;&#10;        if (result.getExitCode() != 0) {&#10;            System.err.println(&quot;Maven compilation failed. Output:&quot;);&#10;            System.err.println(mvnLog);&#10;            throw new IllegalStateException(&quot;Maven compilation failed with exit code: &quot; + result.getExitCode());&#10;        }&#10;&#10;        System.out.println(&quot;✅ Maven project compiled successfully.&quot;);&#10;    }&#10;&#10;    // =========================================================================&#10;    // STEP -1a: Run PITest Mutation Coverage Analysis&#10;    // =========================================================================&#10;    private void runPitestMutationCoverage(String projectPath) throws Exception {&#10;        System.out.println(&quot;Running PITest mutation coverage analysis...&quot;);&#10;&#10;        // Check if PITest reports already exist&#10;        File pitReportsDir = new File(projectPath, &quot;target/pit-reports&quot;);&#10;        File lineCoverageFile = new File(pitReportsDir, &quot;linecoverage.xml&quot;);&#10;&#10;        if (lineCoverageFile.exists() &amp;&amp; lineCoverageFile.isFile()) {&#10;            System.out.println(&quot;✅ PITest reports already exist, skipping PITest execution.&quot;);&#10;            System.out.println(&quot;✅ Found existing linecoverage.xml at: &quot; + lineCoverageFile.getAbsolutePath());&#10;            return;&#10;        }&#10;&#10;        System.out.println(&quot;No existing PITest reports found. Running PITest...&quot;);&#10;&#10;        Invoker invoker = new DefaultInvoker();&#10;        invoker.setWorkingDirectory(new File(projectPath));&#10;        File mavenHome = new File(System.getenv(&quot;MAVEN_HOME&quot;));&#10;        if (!mavenHome.isDirectory()) {&#10;            throw new IllegalStateException(&quot;MAVEN_HOME must point to a valid directory&quot;);&#10;        }&#10;        invoker.setMavenHome(mavenHome);&#10;&#10;        InvocationRequest req = new DefaultInvocationRequest();&#10;        req.setPomFile(new File(projectPath, &quot;pom.xml&quot;));&#10;        req.setGoals(Collections.singletonList(&quot;org.pitest:pitest-maven:mutationCoverage&quot;));&#10;        req.setInputStream(InputStream.nullInputStream());&#10;&#10;        // Set properties to ensure PITest runs with proper configuration&#10;        Properties props = new Properties();&#10;        props.setProperty(&quot;maven.test.failure.ignore&quot;, &quot;true&quot;);&#10;        req.setProperties(props);&#10;&#10;        ByteArrayOutputStream baos = new ByteArrayOutputStream();&#10;        PrintStreamHandler handler = new PrintStreamHandler(new PrintStream(baos), false);&#10;        invoker.setOutputHandler(handler);&#10;        invoker.setErrorHandler(handler);&#10;&#10;        System.out.println(&quot;⏳ This may take several minutes depending on project size...&quot;);&#10;&#10;        InvocationResult result = invoker.execute(req);&#10;        String mvnLog = baos.toString();&#10;&#10;        if (result.getExitCode() != 0) {&#10;            System.err.println(&quot;PITest mutation coverage failed. Output:&quot;);&#10;            System.err.println(mvnLog);&#10;            throw new IllegalStateException(&quot;PITest execution failed with exit code: &quot; + result.getExitCode());&#10;        }&#10;&#10;        System.out.println(&quot;✅ PITest mutation coverage analysis completed successfully.&quot;);&#10;&#10;        // Verify that the PITest reports were generated&#10;        if (pitReportsDir.exists() &amp;&amp; pitReportsDir.isDirectory()) {&#10;            System.out.println(&quot;✅ PITest reports generated in: &quot; + pitReportsDir.getAbsolutePath());&#10;        } else {&#10;            System.out.println(&quot;⚠️ Warning: PITest reports directory not found. Check PITest configuration.&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example;&#10;&#10;import java.io.*;&#10;import java.nio.charset.StandardCharsets;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.nio.file.Paths;&#10;import java.util.*;&#10;&#10;import com.example.classifier.MutationKind;&#10;import com.example.dto.CommitPairDTO;&#10;import com.example.dto.FileResultDto;&#10;import com.example.mapper.CommitPairMapper;&#10;import com.example.mapper.ResultMapper;&#10;import com.example.mutation_tester.mutation_metadata_processing.MethodCallMapper;&#10;import com.example.mutation_tester.mutations_applier.MutationApplier;&#10;import com.example.pojo.FileResult;&#10;import com.example.service.GitRepositoryManager;&#10;import com.example.util.GitUtils;&#10;import com.example.util.JsonUtils;&#10;import com.example.mutation_tester.mutations_applier.custom_patterns.LoopBreakReplacement;&#10;import com.example.mutation_tester.mutations_applier.custom_patterns.TakeWhileDropWhileReplacement;&#10;import com.fasterxml.jackson.core.type.TypeReference;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import org.apache.commons.io.FileUtils;&#10;import org.apache.maven.shared.invoker.*;&#10;import org.eclipse.jgit.lib.Repository;&#10;import org.eclipse.jgit.revwalk.RevCommit;&#10;import org.eclipse.jgit.revwalk.RevWalk;&#10;import org.springframework.beans.factory.ObjectProvider;&#10;import org.springframework.boot.CommandLineRunner;&#10;import org.springframework.boot.autoconfigure.SpringBootApplication;&#10;import org.springframework.boot.SpringApplication;&#10;&#10;import java.nio.file.FileSystemException;&#10;import java.util.concurrent.*;&#10;import java.util.regex.Matcher;&#10;import java.util.regex.Pattern;&#10;import java.util.stream.Collectors;&#10;&#10;@SpringBootApplication&#10;public class Main implements CommandLineRunner {&#10;    private final GitRepositoryManager repoManager;&#10;    private final GitUtils gitUtils;&#10;    private final MutationApplier mutationApplier;&#10;&#10;    ConcurrentMap&lt;MutationKind, Integer&gt; repoPatternCounts =&#10;            new ConcurrentHashMap&lt;&gt;();&#10;&#10;    private final ObjectProvider&lt;TreeComparator&gt; treeComparatorProvider;&#10;    private final int THREAD_COUNT = Runtime.getRuntime().availableProcessors()/2;&#10;&#10;    String localPath = &quot;repositories&quot;;&#10;    final int BATCH_SIZE = 500;&#10;    final String filteredDir = &quot;src/main/resources/programOutputFiltered&quot;;&#10;&#10;    List&lt;String&gt; repoUrls = List.of(&#10;            &quot;https://github.com/kdn251/interviews&quot;,&#10;            &quot;https://github.com/TheAlgorithms/Java&quot;,&#10;            &quot;https://github.com/NationalSecurityAgency/ghidra&quot;,&#10;            &quot;https://github.com/Stirling-Tools/Stirling-PDF&quot;,&#10;            &quot;https://github.com/google/guava&quot;,&#10;            &quot;https://github.com/ReactiveX/RxJava&quot;,&#10;            &quot;https://github.com/skylot/jadx&quot;,&#10;            &quot;https://github.com/dbeaver/dbeaver&quot;,&#10;            &quot;https://github.com/jeecgboot/JeecgBoot&quot;,&#10;            &quot;https://github.com/apache/dubbo&quot;,&#10;            &quot;https://github.com/termux/termux-app&quot;,&#10;            &quot;https://github.com/jhy/jsoup&quot;&#10;    );&#10;&#10;    List&lt;String&gt; extensions = List.of(&quot;.java&quot;);&#10;&#10;    public Main(GitRepositoryManager repoManager,&#10;                TreeComparator treeComparator,&#10;                GitUtils gitUtils,&#10;                MutationApplier mutationApplier,&#10;                ObjectProvider&lt;TreeComparator&gt; treeComparatorProvider) {&#10;        this.repoManager = repoManager;&#10;        this.gitUtils = gitUtils;&#10;        this.mutationApplier = mutationApplier;&#10;        this.treeComparatorProvider = treeComparatorProvider;&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SpringApplication.run(Main.class, args);&#10;    }&#10;&#10;    @Override&#10;    public void run(String... args) throws Exception {&#10;&#10;        // --- Configuration Paths ---&#10;        //String projectPath = &quot;D:\\Java projects\\mutation-analysis\\repositories_for_tests\\jsoup&quot;;&#10;        String projectPath = &quot;D:\\Java projects\\mutation-analysis\\repositories_for_tests\\commons-lang&quot;;&#10;&#10;        // Extract project name from path&#10;        String projectName = extractProjectName(projectPath);&#10;        System.out.println(&quot;Working with project: &quot; + projectName);&#10;&#10;        // =========================================================================&#10;        // STEP -2: Check if PITest reports already exist BEFORE any clean/build&#10;        // =========================================================================&#10;        System.out.println(&quot;STEP -2: Checking for existing PITest reports...&quot;);&#10;&#10;        // Check if PITest reports already exist&#10;        File pitReportsDir = new File(projectPath, &quot;target/pit-reports&quot;);&#10;        File lineCoverageFile = new File(pitReportsDir, &quot;linecoverage.xml&quot;);&#10;&#10;        boolean pitestReportsExist = lineCoverageFile.exists() &amp;&amp; lineCoverageFile.isFile();&#10;&#10;        if (pitestReportsExist) {&#10;            System.out.println(&quot;✅ PITest reports already exist, skipping compilation and PITest execution.&quot;);&#10;            System.out.println(&quot;✅ Found existing linecoverage.xml at: &quot; + lineCoverageFile.getAbsolutePath());&#10;        } else {&#10;            System.out.println(&quot;❌ No existing PITest reports found.&quot;);&#10;&#10;            // =========================================================================&#10;            // STEP -1: Setup PITest Plugin and Compile Project (only if reports don't exist)&#10;            // =========================================================================&#10;            System.out.println(&quot;STEP -1: Setting up PITest plugin and compiling project...&quot;);&#10;            setupPitestPlugin(projectPath);&#10;            compileMavenProject(projectPath);&#10;&#10;            // Run PITest mutation coverage analysis&#10;            runPitestMutationCoverage(projectPath);&#10;&#10;            System.out.println(&quot;✅ Project setup and compilation complete.&quot;);&#10;        }&#10;&#10;        String pitReportPath = projectPath + &quot;/target/pit-reports/linecoverage.xml&quot;;&#10;        String jsonMapPath = projectName + &quot;-method-test-mapping.json&quot;;&#10;&#10;        // =========================================================================&#10;        // STEP 0: Generate the Method-to-Test Map from the PIT Report&#10;        // =========================================================================&#10;        System.out.println(&quot;\nSTEP 0: Generating method-to-test map...&quot;);&#10;        MethodCallMapper mapper = new MethodCallMapper();&#10;        mapper.processCoverage(pitReportPath, &quot;&quot;, projectName);&#10;        System.out.println(&quot;✅ Map generation complete. Saved to: &quot; + jsonMapPath);&#10;&#10;        // =========================================================================&#10;        // STEP 1: Get List of All Mutable Methods (without applying mutations yet)&#10;        // =========================================================================&#10;        System.out.println(&quot;\nSTEP 1: Identifying mutable methods...&quot;);&#10;        var potentialMutationResults = mutationApplier.identifyMutableMethods(&#10;                MutationApplier.CustomMutations.SAFE_STREAM_METHOD_REPLACEMENT, projectPath);&#10;        Set&lt;String&gt; mutableMethods = new HashSet&lt;&gt;(potentialMutationResults);&#10;        System.out.println(&quot;✅ Found &quot; + mutableMethods.size() + &quot; mutable methods across all files.&quot;);&#10;&#10;        // =========================================================================&#10;        // STEP 2: Load the Full Test Map from the Generated JSON&#10;        // =========================================================================&#10;        System.out.println(&quot;\nSTEP 2: Loading test map from JSON...&quot;);&#10;        Map&lt;String, Set&lt;String&gt;&gt; allTestsMap = loadTestMapFromJson(jsonMapPath);&#10;&#10;        // =========================================================================&#10;        // STEP 3: Filter for Tests Covering Mutable Methods&#10;        // =========================================================================&#10;        System.out.println(&quot;\nSTEP 3: Filtering tests for mutable methods...&quot;);&#10;        Map&lt;String, Set&lt;String&gt;&gt; testsToRunMap = allTestsMap.entrySet().stream()&#10;                .filter(entry -&gt; mutableMethods.contains(entry.getKey()))&#10;                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));&#10;&#10;        System.out.println(&quot;✅ Found &quot; + testsToRunMap.values().stream().mapToLong(Set::size).sum()&#10;                + &quot; relevant tests to run.&quot;);&#10;        long uniqueCount = testsToRunMap.values().stream()&#10;                .flatMap(Set::stream)&#10;                .distinct()&#10;                .count();&#10;        System.out.println(&quot;✅ Found &quot; + uniqueCount + &quot; unique relevant tests to run.&quot;);&#10;&#10;        // =========================================================================&#10;        // STEP 4: Mutate and Test Each Method Individually&#10;        // =========================================================================&#10;        System.out.println(&quot;\nSTEP 4: Testing mutations one method at a time...&quot;);&#10;&#10;        Map&lt;String, Set&lt;String&gt;&gt; globalFailedTestsReport = new HashMap&lt;&gt;();&#10;        int methodCount = 0;&#10;        int totalMethods = testsToRunMap.size();&#10;&#10;        for (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : testsToRunMap.entrySet()) {&#10;            String methodSignature = entry.getKey();&#10;            Set&lt;String&gt; relevantTests = entry.getValue();&#10;            methodCount++;&#10;&#10;            System.out.printf(&quot;\n[%d/%d] Processing method: %s%n&quot;, methodCount, totalMethods, methodSignature);&#10;            System.out.println(&quot;  Relevant tests: &quot; + relevantTests.size());&#10;&#10;            try {&#10;                // Reset project to clean state&#10;                System.out.println(&quot;   Resetting project to clean state...&quot;);&#10;                resetProjectToCleanState(projectPath);&#10;&#10;                // Apply mutation to this specific method only&#10;                System.out.println(&quot;   Applying mutation to method...&quot;);&#10;                boolean mutationApplied = mutationApplier.applyMutationToSpecificMethod(&#10;                        MutationApplier.CustomMutations.SAFE_STREAM_METHOD_REPLACEMENT,&#10;                        projectPath,&#10;                        methodSignature);&#10;&#10;                if (!mutationApplied) {&#10;                    System.out.println(&quot;  ⚠️ No mutation could be applied to this method, skipping...&quot;);&#10;                    continue;&#10;                }&#10;&#10;                // Run tests for this method&#10;                System.out.println(&quot;   Running tests for mutated method...&quot;);&#10;                Map&lt;String, Set&lt;String&gt;&gt; methodTestsMap = new HashMap&lt;&gt;();&#10;                methodTestsMap.put(methodSignature, relevantTests);&#10;&#10;                Map&lt;String, Set&lt;String&gt;&gt; failedTestsForMethod = runBatchedMavenTests(methodTestsMap, projectPath);&#10;&#10;                // Collect results&#10;                if (!failedTestsForMethod.isEmpty()) {&#10;                    globalFailedTestsReport.putAll(failedTestsForMethod);&#10;                    System.out.println(&quot;  ✅ Mutation detected! &quot; + failedTestsForMethod.get(methodSignature).size() + &quot; tests failed.&quot;);&#10;                } else {&#10;                    System.out.println(&quot;  ❌ Mutation not detected - all tests passed.&quot;);&#10;                }&#10;&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;  ❌ Error processing method &quot; + methodSignature + &quot;: &quot; + e.getMessage());&#10;                e.printStackTrace();&#10;            }&#10;        }&#10;&#10;        // Final reset to clean state&#10;        System.out.println(&quot;\n Final reset to clean state...&quot;);&#10;        resetProjectToCleanState(projectPath);&#10;&#10;        // =========================================================================&#10;        // STEP 5: Print Final Report&#10;        // =========================================================================&#10;        System.out.println(&quot;\n--- FINAL REPORT ---&quot;);&#10;        if (globalFailedTestsReport.isEmpty()) {&#10;            System.out.println(&quot;✅ No mutations were detected by the test suite.&quot;);&#10;        } else {&#10;            System.out.println(&quot;❌ Mutations Detected! Found &quot; + globalFailedTestsReport.size() + &quot; methods with failing tests.&quot;);&#10;        }&#10;&#10;        // =====================&#10;        // STATISTICS PER METHOD&#10;        // =====================&#10;        System.out.println(&quot;\n--- STATISTICS PER MUTATED METHOD ---&quot;);&#10;        testsToRunMap.forEach((method, relevantTests) -&gt; {&#10;            int totalRelevant = relevantTests.size();&#10;            Set&lt;String&gt; failedTests = globalFailedTestsReport.getOrDefault(method, Collections.emptySet());&#10;            int failed = failedTests.size();&#10;            &#10;            // For passed calculation, we need to be more careful&#10;            // If we have failed tests, then passed = relevant - failed&#10;            // But we need to make sure we don't go negative&#10;            int passed = Math.max(0, totalRelevant - failed);&#10;            &#10;            // Calculate mutant survival and effectiveness&#10;            boolean mutantSurvived = failed == 0;&#10;            // CORRECTED: Mutant is MORE effective when MORE tests PASS (mutation not detected)&#10;            double effectiveness = totalRelevant &gt; 0 ? (double) passed / totalRelevant * 100.0 : 0.0;&#10;            &#10;            System.out.println(&quot;Method: &quot; + method);&#10;            System.out.println(&quot;  Total relevant tests: &quot; + totalRelevant);&#10;            System.out.println(&quot;  Passed: &quot; + passed);&#10;            System.out.println(&quot;  Failed: &quot; + failed);&#10;            System.out.printf(&quot;  Mutant survived: %s%n&quot;, mutantSurvived ? &quot;YES&quot; : &quot;NO&quot;);&#10;            System.out.printf(&quot;  Mutant effectiveness: %.1f%% (%d/%d tests passed after mutation)%n&quot;, &#10;                    effectiveness, passed, totalRelevant);&#10;            System.out.println();&#10;        });&#10;        &#10;        // =====================&#10;        // SUMMARY STATISTICS&#10;        // =====================&#10;        System.out.println(&quot;--- MUTATION ANALYSIS SUMMARY ---&quot;);&#10;        int totalMethods = testsToRunMap.size();&#10;        int detectedMutants = globalFailedTestsReport.size();&#10;        int survivedMutants = totalMethods - detectedMutants;&#10;        double overallDetectionRate = totalMethods &gt; 0 ? (double) detectedMutants / totalMethods * 100.0 : 0.0;&#10;        &#10;        int totalRelevantTests = testsToRunMap.values().stream().mapToInt(Set::size).sum();&#10;        int totalFailedTests = globalFailedTestsReport.values().stream().mapToInt(Set::size).sum();&#10;        int totalPassedTests = totalRelevantTests - totalFailedTests;&#10;        // CORRECTED: Overall mutant effectiveness = how many tests passed across all mutations&#10;        double overallMutantEffectiveness = totalRelevantTests &gt; 0 ? (double) totalPassedTests / totalRelevantTests * 100.0 : 0.0;&#10;        &#10;        System.out.printf(&quot;Total mutated methods: %d%n&quot;, totalMethods);&#10;        System.out.printf(&quot;Detected mutants: %d%n&quot;, detectedMutants);&#10;        System.out.printf(&quot;Survived mutants: %d%n&quot;, survivedMutants);&#10;        System.out.printf(&quot;Mutation detection rate: %.1f%%%n&quot;, overallDetectionRate);&#10;        System.out.printf(&quot;Overall mutant effectiveness: %.1f%% (%d passed out of %d total relevant tests)%n&quot;, &#10;                overallMutantEffectiveness, totalPassedTests, totalRelevantTests);&#10;        System.out.printf(&quot;Test suite strength: %.1f%% (%d failed out of %d total relevant tests)%n&quot;, &#10;                100.0 - overallMutantEffectiveness, totalFailedTests, totalRelevantTests);&#10;    }&#10;&#10;    private static Map&lt;String, Set&lt;String&gt;&gt; loadTestMapFromJson(String jsonFilePath) {&#10;        ObjectMapper objectMapper = new ObjectMapper();&#10;        Map&lt;String, Set&lt;String&gt;&gt; testMap = new HashMap&lt;&gt;();&#10;&#10;        try {&#10;            Map&lt;String, List&lt;String&gt;&gt; rawMap = objectMapper.readValue(&#10;                    new File(jsonFilePath),&#10;                    new TypeReference&lt;Map&lt;String, List&lt;String&gt;&gt;&gt;() {}&#10;            );&#10;&#10;            for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : rawMap.entrySet()) {&#10;                testMap.put(entry.getKey(), new HashSet&lt;&gt;(entry.getValue()));&#10;            }&#10;&#10;            System.out.println(&quot;Successfully loaded test map from: &quot; + jsonFilePath);&#10;&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error loading test map from JSON file: &quot; + jsonFilePath);&#10;            System.err.println(&quot;Error details: &quot; + e.getMessage());&#10;        }&#10;        return testMap;&#10;    }&#10;&#10;    private static final Pattern TEST_SUMMARY_PATTERN = Pattern.compile(&quot;Tests run: (\\d+), Failures: (\\d+), Errors: (\\d+), Skipped: (\\d+)&quot;);&#10;    private static final Pattern FAILURE_LINE_PATTERN = Pattern.compile(&quot;\\[ERROR\\]\\s+([^\\s]+)\\s+--\\s+Time elapsed:.*&lt;&lt;&lt; FAILURE!&quot;);&#10;    private static final Pattern ERROR_LINE_PATTERN = Pattern.compile(&quot;\\[ERROR\\]\\s+([^\\s]+)\\s+--\\s+Time elapsed:.*&lt;&lt;&lt; ERROR!&quot;);&#10;&#10;    public Map&lt;String, Set&lt;String&gt;&gt; runBatchedMavenTests(&#10;            Map&lt;String, Set&lt;String&gt;&gt; testsToRunMap,&#10;            String projectPath&#10;    ) throws IOException, MavenInvocationException {&#10;        Map&lt;String, Set&lt;String&gt;&gt; failedTestsReport = new HashMap&lt;&gt;();&#10;        int totalRun = 0, totalFailures = 0, totalErrors = 0, totalSkipped = 0;&#10;&#10;        Invoker invoker = new DefaultInvoker();&#10;        invoker.setWorkingDirectory(new File(projectPath));&#10;        File mavenHome = new File(System.getenv(&quot;MAVEN_HOME&quot;));&#10;        if (!mavenHome.isDirectory()) {&#10;            throw new IllegalStateException(&quot;MAVEN_HOME must point to a valid directory&quot;);&#10;        }&#10;        invoker.setMavenHome(mavenHome);&#10;&#10;        for (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : testsToRunMap.entrySet()) {&#10;            String batchKey = entry.getKey();&#10;            Set&lt;String&gt; tests = entry.getValue();&#10;            if (tests.isEmpty()) continue;&#10;&#10;            try {&#10;                // Convert test format for Maven Surefire&#10;                Set&lt;String&gt; testClasses = new HashSet&lt;&gt;();&#10;                for (String test : tests) {&#10;                    if (test.contains(&quot;#&quot;)) {&#10;                        // Extract class name from &quot;package.Class#method&quot;&#10;                        String className = test.substring(0, test.indexOf(&quot;#&quot;));&#10;                        testClasses.add(className);&#10;                    } else {&#10;                        // If it's just a class name&#10;                        testClasses.add(test);&#10;                    }&#10;                }&#10;&#10;                // Join test classes with comma for -Dtest parameter&#10;                String testParameter = String.join(&quot;,&quot;, testClasses);&#10;&#10;                // Debug: print what tests we're running&#10;                System.out.println(&quot;DEBUG: Running tests for method &quot; + batchKey + &quot;:&quot;);&#10;                System.out.println(&quot;  Original tests: &quot; + tests.size());&#10;                System.out.println(&quot;  Test classes: &quot; + testClasses.size());&#10;                System.out.println(&quot;  Test parameter: &quot; + testParameter);&#10;&#10;                InvocationRequest req = new DefaultInvocationRequest();&#10;                req.setPomFile(new File(projectPath, &quot;pom.xml&quot;));&#10;                req.setGoals(Collections.singletonList(&quot;test&quot;));&#10;                req.setInputStream(InputStream.nullInputStream());&#10;&#10;                Properties props = new Properties();&#10;                // Use -Dtest parameter instead of includesFile&#10;                props.setProperty(&quot;test&quot;, testParameter);&#10;                props.setProperty(&quot;maven.test.failure.ignore&quot;, &quot;true&quot;);&#10;                props.setProperty(&quot;failIfNoTests&quot;, &quot;false&quot;);&#10;                req.setProperties(props);&#10;&#10;                ByteArrayOutputStream baos = new ByteArrayOutputStream();&#10;                PrintStreamHandler handler = new PrintStreamHandler(new PrintStream(baos), false);&#10;                invoker.setOutputHandler(handler);&#10;                invoker.setErrorHandler(handler);&#10;&#10;                InvocationResult result = invoker.execute(req);&#10;                String mvnLog = baos.toString();&#10;&#10;                // Debug: print Maven log excerpt for verification&#10;                System.out.println(&quot;DEBUG: Maven execution result (exit code: &quot; + result.getExitCode() + &quot;)&quot;);&#10;                String[] logLines = mvnLog.split(&quot;\n&quot;);&#10;                for (String logLine : logLines) {&#10;                    if (logLine.contains(&quot;Tests run:&quot;) || logLine.contains(&quot;Running&quot;) ||&#10;                        logLine.contains(&quot;No tests to run&quot;) || logLine.contains(&quot;T E S T S&quot;)) {&#10;                        System.out.println(&quot;  &quot; + logLine.trim());&#10;                    }&#10;                }&#10;&#10;                Matcher summaryMatcher = TEST_SUMMARY_PATTERN.matcher(mvnLog);&#10;                int run = 0, failures = 0, errors = 0, skipped = 0;&#10;                while (summaryMatcher.find()) {&#10;                    run = Integer.parseInt(summaryMatcher.group(1));&#10;                    failures = Integer.parseInt(summaryMatcher.group(2));&#10;                    errors = Integer.parseInt(summaryMatcher.group(3));&#10;                    skipped = Integer.parseInt(summaryMatcher.group(4));&#10;                }&#10;&#10;                // If no tests were found, this might indicate a mapping issue&#10;                if (run == 0) {&#10;                    System.out.println(&quot;WARNING: No tests were executed for method &quot; + batchKey);&#10;                    System.out.println(&quot;This could indicate a mapping issue between method and test names.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                int passed = run - failures - errors - skipped;&#10;                totalRun += run;&#10;                totalFailures += failures;&#10;                totalErrors += errors;&#10;                totalSkipped += skipped;&#10;&#10;                System.out.printf(&#10;                        &quot;[BATCH %s] run=%d, passed=%d, failures=%d, errors=%d, skipped=%d%n&quot;,&#10;                        batchKey, run, passed, failures, errors, skipped&#10;                );&#10;&#10;                // Collect failed tests&#10;                Set&lt;String&gt; failedThisBatch = new HashSet&lt;&gt;();&#10;&#10;                Matcher fm = FAILURE_LINE_PATTERN.matcher(mvnLog);&#10;                while (fm.find()) {&#10;                    String formatted = convertSurefireToCustomFormat(fm.group(1));&#10;                    failedThisBatch.add(formatted);&#10;                }&#10;&#10;                Matcher em = ERROR_LINE_PATTERN.matcher(mvnLog);&#10;                while (em.find()) {&#10;                    String formatted = convertSurefireToCustomFormat(em.group(1));&#10;                    failedThisBatch.add(formatted);&#10;                }&#10;&#10;                // If we detected failures but didn't capture any failed tests, use fallback&#10;                if ((failures &gt; 0 || errors &gt; 0) &amp;&amp; failedThisBatch.isEmpty()) {&#10;                    System.out.println(&quot;Warning: Detected &quot; + failures + &quot; failures and &quot; + errors + &quot; errors but couldn't parse test names. Using fallback strategy.&quot;);&#10;                    // Add all tests from this batch as potentially failed&#10;                    failedThisBatch.addAll(tests);&#10;                }&#10;&#10;                if (!failedThisBatch.isEmpty()) {&#10;                    failedTestsReport.put(batchKey, failedThisBatch);&#10;                    System.out.println(&quot;Captured &quot; + failedThisBatch.size() + &quot; failed tests for method: &quot; + batchKey);&#10;                }&#10;&#10;            } finally {&#10;                invoker.setOutputHandler(new PrintStreamHandler(System.out, true));&#10;                invoker.setErrorHandler(new PrintStreamHandler(System.err, true));&#10;            }&#10;        }&#10;&#10;        int totalPassed = totalRun - totalFailures - totalErrors - totalSkipped;&#10;        System.out.printf(&#10;                &quot;TOTAL → run=%d, passed=%d, failures=%d, errors=%d, skipped=%d%n&quot;,&#10;                totalRun, totalPassed, totalFailures, totalErrors, totalSkipped&#10;        );&#10;&#10;        return failedTestsReport;&#10;    }&#10;&#10;    private static String convertSurefireToCustomFormat(String surefireFormat) {&#10;        if (surefireFormat == null || surefireFormat.isEmpty()) {&#10;            return surefireFormat;&#10;        }&#10;        int lastDot = surefireFormat.lastIndexOf(&quot;.&quot;);&#10;        if (lastDot != -1) {&#10;            String className = surefireFormat.substring(0, lastDot);&#10;            String methodName = surefireFormat.substring(lastDot + 1);&#10;            return className + &quot;#&quot; + methodName;&#10;        }&#10;        return surefireFormat;&#10;    }&#10;&#10;    // Helper method to extract failed test names from Maven output.&#10;// This is a rudimentary parser; for production, consider parsing Surefire's XML reports.&#10;    private static String extractFailedTestName(String line, Set&lt;String&gt; allTestsInBatch) {&#10;        // Example lines:&#10;        // [ERROR] org.jsoup.nodes.AttributesTest.testListSkipsInternal -- Time elapsed: 0.035 s &lt;&lt;&lt; FAILURE!&#10;        // [ERROR] Failures: AttributesTest.testListSkipsInternal&#10;        // [ERROR] Error: TestClass.testMethod&#10;        if (line.contains(&quot;&lt;&lt;&lt; FAILURE!&quot;)) {&#10;            // Try to find the full test name (class#method)&#10;            int classMethodEnd = line.indexOf(&quot; -- Time elapsed:&quot;);&#10;            if (classMethodEnd != -1) {&#10;                String candidate = line.substring(line.indexOf(&quot;]&quot;) + 2, classMethodEnd).trim();&#10;                // Need to convert to your format (e.g., org.jsoup.nodes.AttributesTest#testListSkipsInternal)&#10;                if (candidate.contains(&quot;.&quot;)) {&#10;                    int lastDot = candidate.lastIndexOf(&quot;.&quot;);&#10;                    if (lastDot != -1) {&#10;                        String className = candidate.substring(0, lastDot);&#10;                        String methodName = candidate.substring(lastDot + 1);&#10;                        String formatted = className + &quot;#&quot; + methodName;&#10;                        if (allTestsInBatch.contains(formatted)) {&#10;                            return formatted;&#10;                        }&#10;                        // Also check for just class name if the test filter was a class&#10;                        if (allTestsInBatch.contains(className)) {&#10;                            return className;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } else if (line.contains(&quot;[ERROR] Failures: &quot;) || line.contains(&quot;[ERROR] Error: &quot;)) {&#10;            String testPart = line.substring(line.indexOf(&quot;:&quot;) + 1).trim();&#10;            // It might be &quot;TestClass.testMethod&quot; or &quot;TestClass.testMethod: lineNumber&quot;&#10;            int colonIndex = testPart.indexOf(&quot;:&quot;);&#10;            if (colonIndex != -1) {&#10;                testPart = testPart.substring(0, colonIndex);&#10;            }&#10;            testPart = testPart.trim();&#10;&#10;            // Convert Surefire's &quot;package.Class.method&quot; to your &quot;package.Class#method&quot;&#10;            int lastDot = testPart.lastIndexOf(&quot;.&quot;);&#10;            if (lastDot != -1) {&#10;                String className = testPart.substring(0, lastDot);&#10;                String methodName = testPart.substring(lastDot + 1);&#10;                String formatted = className + &quot;#&quot; + methodName;&#10;                if (allTestsInBatch.contains(formatted)) {&#10;                    return formatted;&#10;                }&#10;                // Also check for just class name if the test filter was a class&#10;                if (allTestsInBatch.contains(className)) {&#10;                    return className;&#10;                }&#10;            } else {&#10;                // If it's just a class name (e.g., &quot;MyTestClass&quot;)&#10;                if (allTestsInBatch.contains(testPart)) {&#10;                    return testPart;&#10;                }&#10;            }&#10;        }&#10;        return null; // Test name not found or line didn't match expected failure pattern&#10;    }&#10;&#10;    public void presentation(List&lt;String&gt; repoUrls) throws InterruptedException {&#10;        for (String repoUrl : repoUrls) {&#10;&#10;            for (MutationKind k : MutationKind.values()) {&#10;                repoPatternCounts.put(k, 0);&#10;            }&#10;&#10;            String repoName = repoUrl.substring(repoUrl.lastIndexOf(&quot;/&quot;) + 1);&#10;            String repoDir  = localPath + File.separator + repoName;&#10;&#10;            System.out.println(&quot;Processing repo: &quot; + repoName);&#10;&#10;            List&lt;CommitPairWithFiles&gt; commitPairs;&#10;&#10;            try {&#10;                var repository = GitUtils.ensureClonedAndLoaded(repoUrl, repoDir);&#10;&#10;                String cacheFilePath = &quot;src/main/resources/cache/&quot; + repoName + &quot;-commitPairs.json&quot;;&#10;                File cacheFile = new File(cacheFilePath);&#10;&#10;                if (cacheFile.exists()) {&#10;                    System.out.println(&quot;Loading cached commit pairs...&quot;);&#10;                    List&lt;CommitPairDTO&gt; dtos = JsonUtils.readCommitPairDTOsFromFile(cacheFilePath);&#10;                    commitPairs = CommitPairMapper.fromDTOs(repository, dtos);&#10;                } else {&#10;                    System.out.println(&quot;Generating commit pairs...&quot;);&#10;                    commitPairs = GitUtils.processRepo(repoUrl, repoDir, extensions, false);&#10;                    List&lt;CommitPairDTO&gt; dtos = CommitPairMapper.toDTOs(commitPairs);&#10;                    JsonUtils.writeCommitPairDTOsToFile(dtos, cacheFilePath);&#10;                }&#10;&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error processing &quot; + repoUrl + &quot;: &quot; + e.getMessage());&#10;                continue;&#10;            }&#10;&#10;            if (commitPairs == null || commitPairs.isEmpty()) {&#10;                System.out.println(&quot;No commits for &quot; + repoUrl);&#10;                continue;&#10;            }&#10;&#10;            JsonUtils.initializeJsonOutput(repoUrl);&#10;&#10;            int totalPairs = commitPairs.size();&#10;            System.out.println(&quot;Total commit pairs to process: &quot; + totalPairs);&#10;&#10;            for (int batchStart = 0; batchStart &lt; totalPairs; batchStart += BATCH_SIZE) {&#10;                int batchEnd = Math.min(batchStart + BATCH_SIZE, totalPairs);&#10;                List&lt;CommitPairWithFiles&gt; batch = commitPairs.subList(batchStart, batchEnd);&#10;&#10;                System.out.printf(&quot;Processing batch %d - %d / %d%n&quot;, batchStart + 1, batchEnd, totalPairs);&#10;                processBatch(batch, repoDir, repoUrl);&#10;&#10;                long used = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();&#10;                System.out.println(&quot;Memory used (MB): &quot; + used / (1024 * 1024));&#10;            }&#10;&#10;            JsonUtils.appendPatternCounts(repoUrl, repoPatternCounts);&#10;            System.out.println(&quot;Wrote patternCounts for &quot; + repoName);&#10;&#10;            JsonUtils.filterUniqueOperations(repoUrl);&#10;&#10;            repoManager.closeRepository();&#10;&#10;            System.out.println();&#10;        }&#10;    }&#10;&#10;    private void processBatch(List&lt;CommitPairWithFiles&gt; batch, String repoDir, String repoUrl)&#10;    {&#10;        long totalStart = System.currentTimeMillis();&#10;&#10;        int totalFiles = batch.stream()&#10;                .mapToInt(pair -&gt; pair.changedFiles().size())&#10;                .sum();&#10;        System.out.printf(&quot;Processing %d commit pairs with a total of %d changed files%n&quot;, batch.size(), totalFiles);&#10;&#10;        ExecutorService exec = Executors.newFixedThreadPool(THREAD_COUNT);&#10;        CompletionService&lt;Void&gt; cs = new ExecutorCompletionService&lt;&gt;(exec);&#10;&#10;        Queue&lt;FileResultDto&gt; batchResults = new ConcurrentLinkedQueue&lt;&gt;();&#10;        ConcurrentMap&lt;MutationKind, Integer&gt; safePatternCounts = new ConcurrentHashMap&lt;&gt;();&#10;&#10;        // Silence Spoon JDT errors&#10;        System.setErr(new ErrorFilterPrintStream(System.err));&#10;&#10;        ThreadLocal&lt;TreeComparator&gt; localComparator = ThreadLocal.withInitial(() -&gt; treeComparatorProvider.getObject());&#10;&#10;        long submissionStart = System.currentTimeMillis();&#10;        int taskCount = 0;&#10;&#10;        for (CommitPairWithFiles pair : batch) {&#10;            for (String file : pair.changedFiles()) {&#10;                cs.submit(() -&gt; {&#10;                    if (Thread.currentThread().isInterrupted()) return null;&#10;&#10;                    FileResult result = localComparator.get().compareFileInTwoCommits(&#10;                            repoDir, pair.oldCommit(), pair.newCommit(), file, false&#10;                    );&#10;&#10;                    if (result != null) {&#10;&#10;                        Map&lt;String, Integer&gt; fileMetrics = result.getMetrics();&#10;                        if (fileMetrics != null) {&#10;                            fileMetrics.forEach((key, count) -&gt; {&#10;                                try {&#10;                                    MutationKind kind = MutationKind.valueOf(key);&#10;                                    safePatternCounts.merge(kind, count, Integer::sum);&#10;                                } catch (IllegalArgumentException ignored) {&#10;                                    // Ignore non-pattern metrics&#10;                                }&#10;                            });&#10;                        }&#10;&#10;                        if (!result.getEditOperations().isEmpty()) {&#10;                            FileResultDto dto = ResultMapper.toDto(result);&#10;                            batchResults.add(dto);&#10;                        }&#10;&#10;                    }&#10;&#10;&#10;&#10;                    return null;&#10;                });&#10;                taskCount++;&#10;            }&#10;        }&#10;&#10;        long submissionEnd = System.currentTimeMillis();&#10;        System.out.printf(&quot;Time to submit %d tasks: %.2f seconds%n&quot;, taskCount, (submissionEnd - submissionStart) / 1000.0);&#10;&#10;        int completed = 0;&#10;        long processingStart = System.currentTimeMillis();&#10;        long lastPrintTime = System.currentTimeMillis();&#10;&#10;        while (completed &lt; taskCount) {&#10;            try {&#10;                Future&lt;Void&gt; future = cs.take();&#10;                future.get();&#10;                completed++;&#10;&#10;                long now = System.currentTimeMillis();&#10;                if (now - lastPrintTime &gt;= 1000 || completed == taskCount) { // throttle to once per second or on final&#10;                    printProgressBar(completed, taskCount);&#10;                    lastPrintTime = now;&#10;                }&#10;&#10;            } catch (ExecutionException e) {&#10;                System.err.println(&quot;Task failed: &quot; + e.getCause());&#10;            } catch (InterruptedException e) {&#10;                System.err.println(&quot;Processing interrupted.&quot;);&#10;                Thread.currentThread().interrupt(); // Preserve interrupt flag&#10;                break;&#10;            }&#10;        }&#10;&#10;        long processingEnd = System.currentTimeMillis();&#10;        System.out.printf(&quot;Time to process batch: %.2f seconds%n&quot;, (processingEnd - processingStart) / 1000.0);&#10;&#10;        exec.shutdown();&#10;        System.out.println();&#10;&#10;        long jsonStart = System.currentTimeMillis();&#10;        JsonUtils.appendBatchResults(repoUrl, new ArrayList&lt;&gt;(batchResults));&#10;        batchResults.clear();&#10;        long jsonEnd = System.currentTimeMillis();&#10;        System.out.printf(&quot;Time to write JSON results: %.2f seconds%n&quot;, (jsonEnd - jsonStart) / 1000.0);&#10;&#10;        long totalEnd = System.currentTimeMillis();&#10;        System.out.printf(&quot;Total time for processBatch: %.2f seconds%n&quot;, (totalEnd - totalStart) / 1000.0);&#10;&#10;        // Update shared repoPatternCounts after batch is done&#10;        safePatternCounts.forEach((k, v) -&gt;&#10;                repoPatternCounts.merge(k, v, Integer::sum)&#10;        );&#10;    }&#10;&#10;    private  void printProgressBar(int current, int total) {&#10;        int width = 50;&#10;        int filled = (int)(width * current / (double)total);&#10;        StringBuilder b = new StringBuilder(&quot;\r[&quot;);&#10;        for (int i = 0; i &lt; width; i++) {&#10;            b.append(i &lt; filled ? '=' : ' ');&#10;        }&#10;        b.append(&quot;] &quot;)&#10;                .append(String.format(&quot;%3d%%&quot;, (int)(current*100.0/total)));&#10;        System.out.print(b);&#10;        System.out.flush();&#10;    }&#10;&#10;    public void loopBreakReplacementTest(){&#10;        try {&#10;            Path inputPath = Paths.get(&quot;src/main/java/com/example/mutations_applier/test/before.java&quot;);&#10;            // Path to the output file &quot;after.java&quot;&#10;            Path outputPath = Paths.get(&quot;src/main/java/com/example/mutations_applier/test/after.java&quot;);&#10;&#10;            // Read the content of &quot;before.java&quot;&#10;            String originalCode = new String(Files.readAllBytes(inputPath));&#10;&#10;            // Apply the mutation using loopBreakReplacement&#10;            LoopBreakReplacement mutator = new LoopBreakReplacement();&#10;            String mutatedCode = mutator.mutate(originalCode).getMutatedUnit().toString();&#10;&#10;            // Write the mutated code to &quot;after.java&quot;&#10;            Files.write(outputPath, mutatedCode.getBytes());&#10;&#10;            System.out.println(&quot;Mutation applied. Check after.java.&quot;);&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public  void manualTest() {&#10;&#10;&#10;        String localRepoName = &quot;D:\\Java projects\\mutation-analysis\\repositories\\spring-framework\\.git&quot;;&#10;        String oldSha = &quot;253f321e8b81aa5f652117514c37cb541f2e5ecf&quot;;&#10;        String newSha = &quot;014a395aed7b3f40bb05f1591149e833f2bf7537&quot;;&#10;        String fileName = &quot;spring-context/src/test/java/org/springframework/aop/framework/AbstractAopProxyTests.java&quot;;&#10;&#10;        String outputDir = &quot;D:\\Java projects\\mutation-analysis\\src\\main\\resources\\extractedFiles&quot;;&#10;        cleanUp(outputDir);&#10;&#10;&#10;        Repository repo = GitUtils.ensureClonedAndLoaded(&quot;&quot;, localRepoName);&#10;        RevCommit oldCommit = null;&#10;        RevCommit newCommit = null;&#10;        try (RevWalk walk = new RevWalk(repo)) {&#10;            oldCommit = walk.parseCommit(repo.resolve(oldSha));&#10;            newCommit = walk.parseCommit(repo.resolve(newSha));&#10;        } catch (Exception exception){&#10;            exception.printStackTrace();&#10;        }&#10;&#10;&#10;        //List&lt;String&gt; extractedPaths = GitUtils.extractFileAtTwoCommits(localPath + &quot;\\&quot; + localRepoName, relativePath, oldSha, newSha, outputDir);&#10;        //List&lt;String&gt; extractedPaths = List.of(&quot;D:\\\\Java projects\\\\mutation-analysis\\\\src\\\\main\\\\java\\\\com\\\\example\\\\test\\\\file1.java&quot;, &quot;D:\\\\Java projects\\\\mutation-analysis\\\\src\\\\main\\\\java\\\\com\\\\example\\\\test\\\\file2.java&quot;);&#10;&#10;        TreeComparator localComparator = treeComparatorProvider.getObject();&#10;        FileResult result = localComparator.compareFileInTwoCommits(&quot;&quot;, oldCommit, newCommit, fileName, true);&#10;&#10;        if (result != null) {&#10;            System.out.println(result);&#10;        } else {&#10;            System.out.println(&quot;Comparison failed.&quot;);&#10;        }&#10;&#10;    }&#10;&#10;    public  void manualTestLocal() {&#10;&#10;        TreeComparator localComparator = treeComparatorProvider.getObject();&#10;        FileResult result = localComparator.compareTwoFilePaths(&#10;                &quot;D:\\Java projects\\mutation-analysis\\src\\main\\java\\com\\example\\test\\file1.java&quot;,&#10;                &quot;D:\\Java projects\\mutation-analysis\\src\\main\\java\\com\\example\\test\\file2.java&quot;,&#10;                true&#10;        );&#10;&#10;        if (result != null) {&#10;            System.out.println(result);&#10;        } else {&#10;            System.out.println(&quot;Comparison failed.&quot;);&#10;        }&#10;&#10;    }&#10;&#10;    public  void cleanUp(String path) {&#10;        try {&#10;            File dir = new File(path);&#10;            if (dir.exists() &amp;&amp; dir.isDirectory()) {&#10;                FileUtils.deleteDirectory(dir);&#10;            }&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Cleanup failed on: &quot; + ((e instanceof FileSystemException)&#10;                    ? ((FileSystemException)e).getFile() + &quot;  because: &quot; + ((FileSystemException)e).getReason()&#10;                    : e.getMessage()));&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extracts the project name from the given project path.&#10;     * @param projectPath the full path to the project&#10;     * @return the project name (last directory in the path)&#10;     */&#10;    private String extractProjectName(String projectPath) {&#10;        if (projectPath == null || projectPath.isEmpty()) {&#10;            return &quot;unknown-project&quot;;&#10;        }&#10;&#10;        // Handle both forward and backward slashes&#10;        String normalizedPath = projectPath.replace('/', File.separatorChar);&#10;&#10;        // Remove trailing separator if present&#10;        if (normalizedPath.endsWith(File.separator)) {&#10;            normalizedPath = normalizedPath.substring(0, normalizedPath.length() - 1);&#10;        }&#10;&#10;        int lastSeparatorIndex = normalizedPath.lastIndexOf(File.separatorChar);&#10;        if (lastSeparatorIndex == -1) {&#10;            return normalizedPath; // No separator found, return the whole path&#10;        }&#10;&#10;        return normalizedPath.substring(lastSeparatorIndex + 1);&#10;    }&#10;&#10;    /**&#10;     * Resets the project to clean state using git checkout .&#10;     * @param projectPath the path to the project directory&#10;     * @throws Exception if git reset fails&#10;     */&#10;    private void resetProjectToCleanState(String projectPath) throws Exception {&#10;        try {&#10;            ProcessBuilder pb = new ProcessBuilder(&quot;git&quot;, &quot;checkout&quot;, &quot;.&quot;);&#10;            pb.directory(new File(projectPath));&#10;            pb.redirectErrorStream(true);&#10;&#10;            Process process = pb.start();&#10;&#10;            // Read output for debugging&#10;            StringBuilder output = new StringBuilder();&#10;            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {&#10;                String line;&#10;                while ((line = reader.readLine()) != null) {&#10;                    output.append(line).append(&quot;\n&quot;);&#10;                }&#10;            }&#10;&#10;            int exitCode = process.waitFor();&#10;&#10;            if (exitCode != 0) {&#10;                System.err.println(&quot;Git checkout failed with exit code: &quot; + exitCode);&#10;                System.err.println(&quot;Output: &quot; + output.toString());&#10;                throw new RuntimeException(&quot;Failed to reset project to clean state&quot;);&#10;            }&#10;&#10;            // Optional: also clean any untracked files&#10;            ProcessBuilder pbClean = new ProcessBuilder(&quot;git&quot;, &quot;clean&quot;, &quot;-fd&quot;);&#10;            pbClean.directory(new File(projectPath));&#10;            pbClean.redirectErrorStream(true);&#10;&#10;            Process cleanProcess = pbClean.start();&#10;            cleanProcess.waitFor(); // We don't check exit code for clean as it's optional&#10;&#10;        } catch (IOException | InterruptedException e) {&#10;            throw new Exception(&quot;Failed to reset project state: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    // =========================================================================&#10;    // STEP -1: Setup PITest Plugin and Compile Project&#10;    // =========================================================================&#10;    private void setupPitestPlugin(String projectPath) throws Exception {&#10;        System.out.println(&quot;Checking PITest plugin configuration...&quot;);&#10;&#10;        // Check if the PITest plugin is already configured in the pom.xml&#10;        File pomFile = new File(projectPath, &quot;pom.xml&quot;);&#10;        if (!pomFile.exists()) {&#10;            throw new FileNotFoundException(&quot;pom.xml not found in the project directory: &quot; + projectPath);&#10;        }&#10;&#10;        // Check for the presence of the PITest plugin in the pom.xml&#10;        // Look for both groupId and artifactId separately since they're on different lines&#10;        boolean hasOrgPitest = false;&#10;        boolean hasPitestMaven = false;&#10;&#10;        try (var lines = Files.lines(pomFile.toPath())) {&#10;            for (String line : lines.collect(Collectors.toList())) {&#10;                if (line.contains(&quot;org.pitest&quot;)) {&#10;                    hasOrgPitest = true;&#10;                }&#10;                if (line.contains(&quot;pitest-maven&quot;)) {&#10;                    hasPitestMaven = true;&#10;                }&#10;                // If we found both, no need to continue&#10;                if (hasOrgPitest &amp;&amp; hasPitestMaven) {&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;&#10;        boolean pitestConfigured = hasOrgPitest &amp;&amp; hasPitestMaven;&#10;&#10;        if (pitestConfigured) {&#10;            System.out.println(&quot;✅ PITest plugin is already configured.&quot;);&#10;            return;&#10;        }&#10;&#10;        System.out.println(&quot;⚠️ PITest plugin not found. Adding configuration to pom.xml...&quot;);&#10;&#10;        // For this demo, we'll assume the plugin should already be configured manually&#10;        // In a real scenario, you would programmatically add it to the pom.xml&#10;        System.out.println(&quot;Please ensure PITest plugin is configured in your pom.xml&quot;);&#10;    }&#10;&#10;    // =========================================================================&#10;    // STEP -2: Compile Maven Project&#10;    // =========================================================================&#10;    private void compileMavenProject(String projectPath) throws Exception {&#10;        System.out.println(&quot;Compiling Maven project...&quot;);&#10;&#10;        Invoker invoker = new DefaultInvoker();&#10;        invoker.setWorkingDirectory(new File(projectPath));&#10;        File mavenHome = new File(System.getenv(&quot;MAVEN_HOME&quot;));&#10;        if (!mavenHome.isDirectory()) {&#10;            throw new IllegalStateException(&quot;MAVEN_HOME must point to a valid directory&quot;);&#10;        }&#10;        invoker.setMavenHome(mavenHome);&#10;&#10;        InvocationRequest req = new DefaultInvocationRequest();&#10;        req.setPomFile(new File(projectPath, &quot;pom.xml&quot;));&#10;        req.setGoals(Arrays.asList(&quot;clean&quot;, &quot;compile&quot;, &quot;test-compile&quot;));&#10;        req.setInputStream(InputStream.nullInputStream());&#10;&#10;        ByteArrayOutputStream baos = new ByteArrayOutputStream();&#10;        PrintStreamHandler handler = new PrintStreamHandler(new PrintStream(baos), false);&#10;        invoker.setOutputHandler(handler);&#10;        invoker.setErrorHandler(handler);&#10;&#10;        InvocationResult result = invoker.execute(req);&#10;        String mvnLog = baos.toString();&#10;&#10;        if (result.getExitCode() != 0) {&#10;            System.err.println(&quot;Maven compilation failed. Output:&quot;);&#10;            System.err.println(mvnLog);&#10;            throw new IllegalStateException(&quot;Maven compilation failed with exit code: &quot; + result.getExitCode());&#10;        }&#10;&#10;        System.out.println(&quot;✅ Maven project compiled successfully.&quot;);&#10;    }&#10;&#10;    // =========================================================================&#10;    // STEP -1a: Run PITest Mutation Coverage Analysis&#10;    // =========================================================================&#10;    private void runPitestMutationCoverage(String projectPath) throws Exception {&#10;        System.out.println(&quot;Running PITest mutation coverage analysis...&quot;);&#10;&#10;        // Check if PITest reports already exist&#10;        File pitReportsDir = new File(projectPath, &quot;target/pit-reports&quot;);&#10;        File lineCoverageFile = new File(pitReportsDir, &quot;linecoverage.xml&quot;);&#10;&#10;        if (lineCoverageFile.exists() &amp;&amp; lineCoverageFile.isFile()) {&#10;            System.out.println(&quot;✅ PITest reports already exist, skipping PITest execution.&quot;);&#10;            System.out.println(&quot;✅ Found existing linecoverage.xml at: &quot; + lineCoverageFile.getAbsolutePath());&#10;            return;&#10;        }&#10;&#10;        System.out.println(&quot;No existing PITest reports found. Running PITest...&quot;);&#10;&#10;        Invoker invoker = new DefaultInvoker();&#10;        invoker.setWorkingDirectory(new File(projectPath));&#10;        File mavenHome = new File(System.getenv(&quot;MAVEN_HOME&quot;));&#10;        if (!mavenHome.isDirectory()) {&#10;            throw new IllegalStateException(&quot;MAVEN_HOME must point to a valid directory&quot;);&#10;        }&#10;        invoker.setMavenHome(mavenHome);&#10;&#10;        InvocationRequest req = new DefaultInvocationRequest();&#10;        req.setPomFile(new File(projectPath, &quot;pom.xml&quot;));&#10;        req.setGoals(Collections.singletonList(&quot;org.pitest:pitest-maven:mutationCoverage&quot;));&#10;        req.setInputStream(InputStream.nullInputStream());&#10;&#10;        // Set properties to ensure PITest runs with proper configuration&#10;        Properties props = new Properties();&#10;        props.setProperty(&quot;maven.test.failure.ignore&quot;, &quot;true&quot;);&#10;        req.setProperties(props);&#10;&#10;        ByteArrayOutputStream baos = new ByteArrayOutputStream();&#10;        PrintStreamHandler handler = new PrintStreamHandler(new PrintStream(baos), false);&#10;        invoker.setOutputHandler(handler);&#10;        invoker.setErrorHandler(handler);&#10;&#10;        System.out.println(&quot;⏳ This may take several minutes depending on project size...&quot;);&#10;&#10;        InvocationResult result = invoker.execute(req);&#10;        String mvnLog = baos.toString();&#10;&#10;        if (result.getExitCode() != 0) {&#10;            System.err.println(&quot;PITest mutation coverage failed. Output:&quot;);&#10;            System.err.println(mvnLog);&#10;            throw new IllegalStateException(&quot;PITest execution failed with exit code: &quot; + result.getExitCode());&#10;        }&#10;&#10;        System.out.println(&quot;✅ PITest mutation coverage analysis completed successfully.&quot;);&#10;&#10;        // Verify that the PITest reports were generated&#10;        if (pitReportsDir.exists() &amp;&amp; pitReportsDir.isDirectory()) {&#10;            System.out.println(&quot;✅ PITest reports generated in: &quot; + pitReportsDir.getAbsolutePath());&#10;        } else {&#10;            System.out.println(&quot;⚠️ Warning: PITest reports directory not found. Check PITest configuration.&quot;);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>